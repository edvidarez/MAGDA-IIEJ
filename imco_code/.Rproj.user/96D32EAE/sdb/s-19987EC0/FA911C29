{
    "collab_server" : "",
    "contents" : "library(dplyr)\nlibrary(seasonal)\n# library(purrr)\n\n\nentrena_filtro <- TRUE  # Primero se entrenan (filtro == TRUE) y después \n                        # se actualizan los filtros.\n\n# El sufijo BASE se refiere al perioddo de entrenamiento. \n# Incluso con datos nuevos. \nempieza_base <- ymd(\"2011-04-01\")  # Verificar en la serie. \ntermina_base <- ymd(\"2016-10-01\")  # De acuerdo al primer modelo. \n\n\n# Leemos la tabla que ya trae la info por municipio de Banamex y\n# Bancomer, generada por Diego\nspr_src <- read_csv(\"../data/cnbv/processed\" %>% file.path(\n    \"grupos_municipios_prex11.csv\"), \n    col_types = cols(\"c\", \"D\", \"n\", \"n\", \"n\", \"n\")) %>% \n  mutate(CVEMUN = CVEMUN %>% str_pad(5, \"left\", \"0\")) %>% \n  filter(fecha >= empieza_base) %>% \n  gather(\"banco\", \"trans\", bancomer, banamex, valor, otros)\n\n# Valor es equivalente a total, otros es la diferencia entre éste y \n# los otros bancos particulares. \n\n# Este es sólo para comparar. \nspr_src_temp <- spr_src %>%\n  filter(fecha >= \"2011-04-01\") %>%\n  group_by(CVEENT = CVEMUN %>% str_sub(1,2), banco, fecha) %>%\n  summarize(trans = sum(trans, na.rm = T))\n\n\n# Identificamos las que son todas 0, y las quitamos. \nmuns_cero <- spr_src %>% \n  group_by(CVEMUN, banco) %>% \n  summarize(es_cero = all(trans == 0)) %>% \n  filter(es_cero)\n\n\n# La tabla queda en formato de matriz con las \nspr_x11 <- spr_src %>% \n  anti_join(muns_cero, by = c(\"CVEMUN\", \"banco\")) %>% \n  mutate(trans = trans + 1) %>% \n  spread(fecha, trans, fill = 1) \n\n\n### Modificamos las series de tiempo y aplicamos los filtros ###\n\nnames_ls <- sprintf(\"%s_%s\", spr_x11$CVEMUN, spr_x11$banco)\nn_fechas <- if (entrena_filtro) {\n  which(names(spr_x11) == as.character(termina_base)) - 2 \n} else { ncol(spr_x11) - 2 }\n\n\n# Lista de series de tiempo por municipio y banco.\nls1 <- vector(mode = \"list\", length(names_ls))\nfor (i in 1:nrow(spr_x11)) {\n  ls1[[i]] <- spr_x11[i, 3:(n_fechas + 2)] %>% t() %>% as.vector() %>% \n    ts(start = empieza_base %>% {c(year(.), month(.))}, frequency = 12)\n}\nnames(ls1) <- names_ls\n\n\nstatic_x11 <- \"../data/cnbv/x11_models/static_x11s.RDS\"\n# Ver https://github.com/christophsax/seasonal\n\n\nif (entrena_filtro) {\n  # Guardamos los modelos estacionales x11, en modalidad directa, \n  # y estática que sirve para actualizar la serie con nuevos datos. \n  # Se guardan en un mismo ciclo, por motivos \n  cache_x11  <- \"../data/cnbv/x11_models/lista_x11s.RDS\"\n  if (not(file.exists(cache_x11))) {\n    l1  <- vector(\"list\", length(names_ls))\n    st1 <- vector(\"list\", length(names_ls))\n    for (i in 1:length(names_ls)) {\n      # Necesita tener un nombre genérico SEAS_i para llamarlo después. \n      seas_i   <- try (seas(ls1[[i]], x11 = \"\"))\n      l1 [[i]] <- seas_i\n      st1[[i]] <- try (static(seas_i, evaluate = TRUE))\n    }\n    names(l1 ) <- names_ls\n    names(st1) <- names_ls\n    saveRDS(l1,  cache_x11)     \n    saveRDS(st1, static_x11)\n  } else {\n    l1  <- readRDS(cache_x11)\n  }\n  \n} else {  # Actualizamos los nuevos datos con los modelos estáticos.\n  if (not(file.exists(static_x11))) \n    stop (\"No hay lista de modelos estáticos entrenados.\")\n  \n  \n  update_x11 <- \"../data/cnbv/x11_models/update_x11s.RDS\"\n  if (not(file.exists(update_x11))) {\n      \n    # No siguen el mismo orden NAMES_LS que ST1 que se había guardado\n    # anteriormente. \n    st1 <- readRDS(static_x11)\n    \n    l1 <- vector(\"list\", length(names_ls))\n    for (i in seq_along(names_ls)) {  # 1:5){ #\n      nom_i  <- names_ls[i]\n      seas_i <- st1[[nom_i]]\n      print (paste(i, nom_i))\n      if (class(seas_i) == \"seas\") {\n        print (\"Actualizando la serie\")\n        l1[[i]] <- update(seas_i, x = ls1[[nom_i]]) \n      } else {\n        l1[[i]] <- list(NULL)\n        class(l1[[i]]) <- \"try-error\"\n      }\n    }\n    names(l1) <- names_ls\n    saveRDS(l1, update_x11)\n  } else {\n    l1 <- readRDS(update_x11)\n  }\n}\n\n\n\n# Al comparar las series resultantes pueden variar de una computadora \n# a otra\n\nerror_rds <- \"../data/referencias/errores_x11.rds\"\nif (entrena_filtro) {\n  is.err <- sapply(l1, class) == \"try-error\"\n  saveRDS(is.err, error_rds)\n} else {\n  is.err <- readRDS(error_rds)\n}\n\n\n\n\n# También distinguir las que se suman y se multiplican.\n\nfechas <- spr_src$fecha %>% unique() %>% extract(1:n_fechas)\n# fechas <- fechas[1:68]  # para 2016-10\n\ntrend_ <- lapply(l1[!is.err], trend) %>%\n  {do.call(cbind, .)} %>%\n  t() %>% as.data.frame() %>%\n  set_colnames(fechas) %>% \n  mutate(colti = rownames(.))\n\ncycle_ <- lapply(l1[!is.err], . %>% {.$series$d10}) %>%\n  {do.call(cbind, .)} %>%\n  t() %>% as.data.frame() %>% \n  set_colnames(fechas) %>% \n  mutate(colti = rownames(.))\n\ncols_series <- length(fechas)\n\ncycle_$mulsum <- cycle_[, 1:cols_series] %>% \n  apply(1, . %>% abs %>% max)\n\ncycle_ <- cycle_ %>%\n  mutate(mulsum = ifelse(mulsum < 2, \"mul\", \"sum\"))\n\n\n\n\n# Usar transform function.\n\nmul_cycle <- cycle_ %>% filter(mulsum == \"mul\") %>% select(-mulsum)\nmul_trend <- trend_ %>% filter(colti %in% mul_cycle$colti)\n\nmul <- as_data_frame(\n      as.matrix(mul_cycle[,1:cols_series]) * \n      as.matrix(mul_trend[,1:cols_series]) ) %>% \n  mutate(colti = mul_cycle$colti) %>% \n  separate(colti, c(\"CVEMUN\", \"banco\"), sep = \"_\")\n\n\nsum_cycle <- cycle_ %>% filter(mulsum == \"sum\") %>% select(-mulsum)\nsum_trend <- trend_ %>% filter(colti %in% sum_cycle$colti)\n\nsumadas <- as_data_frame(\n       as.matrix(sum_cycle[, 1:cols_series]) + \n       as.matrix(sum_trend[, 1:cols_series])) %>% \n  mutate(colti = sum_cycle$colti) %>% \n  separate(colti, c(\"CVEMUN\", \"banco\"), sep = \"_\")\n\n\n#### Escoger series originales o X11 #### \n\n# Positivas son tentativas\nx11_positivas <- bind_rows(sumadas, mul)\n\n\nspr_idx <- spr_src %>% select(CVEMUN, banco) %>% unique\n\n\nspr_final_tent_ <- spr_idx %>% \n  left_join(x11_positivas, by = c(\"CVEMUN\", \"banco\"))\n\nspr_negativas <- spr_final_tent_ %>% \n  filter(is.na(`2014-11-01`)) %>% \n  select(CVEMUN, banco) %>% \n  left_join(spr_src, by=c(\"CVEMUN\", \"banco\")) %>% \n  spread(fecha, trans, fill = 0) %>% \n  extract(1:nrow(.), 1:(n_fechas + 2))\n\nspr_final_tent <- spr_final_tent_ %>% \n  filter(!is.na(`2014-12-01`)) %>% \n  bind_rows(spr_negativas) %>% \n  gather(\"fecha\", \"trans\", starts_with(\"20\"))\n\nwrite_csv(spr_final_tent, \n  \"../data/cnbv/processed/municipios_todos_x11.csv\")\n\n\n\nspr_final_prueba <- spr_final_tent %>% \n  group_by(CVEENT = str_sub(CVEMUN, 1, 2), banco, fecha) %>% \n  summarize(trans = sum(trans, na.rm = T))\n\nView(spr_final_prueba)\n\n\n\n### Comprobar los x11 generados y las fuentes. \n\ncnbv_original <- spr_src %>% \n  mutate_at(\"fecha\", as.character)\n\ncnbv_x11 <- spr_final_tent\n\ncomparacion_x11 <- left_join(cnbv_x11, cnbv_original, \n      by = c(\"CVEMUN\", \"banco\", \"fecha\"), \n      suffix = c(\"_x11\", \"_or\")) %>%\n  mutate(dif_abs = abs(trans_x11 - trans_or), \n         dif_prc = dif_abs/trans_or)\n\ncorte_mun <- comparacion_x11 %>% \n  group_by(CVEMUN, banco) %>% \n  summarize(mediana = median(dif_prc, na.rm = TRUE)) \n\n# Si la mediana de la diferencia porcentual es mayor que 70%,\n# elegimos la serie de SPR_SRC, que es la original. \ncorte_sust <- corte_mun %>% filter(mediana > 0.7) %>% \n  select(CVEMUN, banco) %>% \n  left_join(spr_src, by = c(\"CVEMUN\", \"banco\")) %>% \n  spread(fecha, trans, fill = 0)\n\n# De lo contrario escogemos las series de SPR_FINAL_TENT. \nspr_final <- spr_final_tent %>% \n  anti_join(corte_sust, by = c(\"CVEMUN\", \"banco\")) %>% \n  spread(fecha, trans, fill = 0) %>% \n  bind_rows(corte_sust)\n\nwrite_csv(spr_final,\n  \"../data/cnbv/processed/municipios_select_x11.csv\")\n\n\ncnbv_input_ <- read_csv(\"../data/cnbv/processed\" %>% file.path(\n      \"municipios_select_x11.csv\")) %>% \n  gather(\"fecha\", \"cnbv_x11\", starts_with(\"20\"), convert = TRUE) %>% \n  spread(banco, cnbv_x11, fill = 0) %>% \n  transmute(CVEMUN = CVEMUN, fecha = fecha, \n      todos_x11 = valor, \n      otros_x11 = otros, \n      suma_x11  = bancomer + banamex + otros,\n      banamex_x11 = banamex, \n      bancomer_x11 = bancomer,\n      menosbancomer_x11 = valor - bancomer, \n      sinbancomer_x11 = banamex + otros) %>% \n  filter(!str_detect(CVEMUN, \"bla\"))\n\ncnbv_input <- cnbv_input_ %>% \n  mutate(trimestre = fecha %>% ymd %>% floor_date(\"quarter\") %>% \n      add(2 %>% months)) %>% \n  group_by(trimestre, CVEMUN) %>% \n  summarize_at(vars(todos_x11, suma_x11, banamex_x11, otros_x11, \n      sinbancomer_x11, bancomer_x11, menosbancomer_x11), \n      funs(. %>% sum(na.rm=TRUE)))\n\nwrite_csv(cnbv_input, \n  \"../data/cnbv/processed/municipios_x11_input.csv\")\n\n\nspr_prueba <- cnbv_input %>% \n  gather(banco, trans, ends_with(\"x11\")) %>% \n  group_by(CVEENT = CVEMUN %>% str_sub(1, 2), banco, \n        trimestre) %>% \n  summarize(trans = sum(trans))\ngg_prueba <- spr_prueba %>% \n  ggplot(aes(trimestre, trans, color = banco)) + \n  facet_wrap(~CVEENT, scales = \"free_y\") +\n  geom_line()\nprint(gg_prueba)\n\nggsave(plot = gg_prueba, \n  \"../visualization/figures/cnbv_confiltros.png\",\n  height = 9, width = 16, dpi = 100)\n\n\n##############################################################\n\n\nmetros_input <- read_csv(\"zonas_metro_estado_ok.csv\" %>% \n      file.path(\"../data/referencias\", .)) %>% \n  select(CVEMET, nombre_corto, CVEMUN) %>% \n  mutate(CVEMET = CVEMET %>% str_pad(3, \"left\", \"0\"), \n         CVEMUN = CVEMUN %>% str_pad(5, \"left\", \"0\")) %>% \n  left_join(cnbv_input, by = \"CVEMUN\") %>% select(-CVEMUN) %>% \n  group_by(trimestre, CVEMET, nombre_corto) %>% \n  summarize_all(funs(sum)) %>% ungroup %>% \n  rename(zona_metro = nombre_corto)\n\nwrite_csv(metros_input, \n  \"../data/cnbv/processed/zonas_metro_x11_input.csv\")\n\nestados_input <- cnbv_input %>%\n  mutate(CVEENT = CVEMUN %>% str_sub(1, 2)) %>% select(-CVEMUN) %>% \n  group_by(trimestre, CVEENT) %>% \n  summarize_all(funs(sum))\n\nwrite_csv(estados_input, \n  \"../data/cnbv/processed/estados_x11_input.csv\")\n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n",
    "created" : 1539037530356.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4269852754",
    "id" : "FA911C29",
    "lastKnownWriteTime" : 1539032711,
    "last_content_update" : 1539032711,
    "path" : "~/programming/pap/otoño/indice-de-actividad-economica/imco_code/2a_limpiar_cnbv_x11.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}